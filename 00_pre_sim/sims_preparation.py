#!usr/bin/python

# TODO: Change the call to something that grabs the outputs to process them

""""
This program prepares the complexes and files to launch PELE simulations.
author: Jelisa Iglesias
mail: jelisa.iglesias@bsc.es
"""

import datetime
import fnmatch
import logging
import os
import sys
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from re import search, findall, finditer, IGNORECASE
from shutil import copyfile, rmtree, move
from string import Template
from subprocess import check_output, CalledProcessError, check_call, STDOUT
from glob import glob
from tempfile import mkdtemp
import numpy as np
# from modules import module

import enviroment_parameters
import help_descriptions
from constant_values import atomic_table_weights, accepted_formats


def createfolder(folder2create_name):
    """
    This function tries to create the folder and catches the errors.
    :param folder2create_name:
    :return: void
    """
    try:
        os.mkdir(folder2create_name)
    except OSError as e:
        if e[1] == "File exists":
            logging.info(" - The folder {0} already exists. So it won't be created again.".format(folder2create_name))
        else:
            logging.error(" - The folder {0} couldn't be created.".format(folder2create_name))
    else:
        logging.info("   - Folder {0} created correctly".format(folder2create_name))


def createsymboliclink(original, link):
    """
    This function tries to create the folder and catches the errors.
    :param original: a string containing the path of the original folder.
    :param link: a string containing the path  where the link should be generated.
    :return: void
    """
    try:
        os.symlink(original, link)
    except OSError as e:
        if e[1] == "File exists":
            logging.info(" - The link {} already exists. So it won't be created again.".format(link2data))
        else:
            logging.error(" - The link {} couldn't be created.".format(link2data))
    else:
        logging.info("   - Link created correctly")


def create_template_and_rotamerlib(initial_pdb, template_folder, rotamer_library_folder, out):
    ploprottemp_wd = mkdtemp(prefix="plop_exec_")
    ploprottemp_wd += os.sep
    ligand_filename_mae = ploprottemp_wd + initial_pdb.split(os.sep)[-1].split(".pdb")[0] + ".mae"
    command2call2 = schrodinger_pdb2mae_convert_command.format(initial_pdb, ligand_filename_mae)
    try:
        check_call(command2call2.split())
    except CalledProcessError as error_message:
        print "The pdbconverter of maestro failed to when being execute. The program will be terminated."
        logging.critical("ERROR: The pdbconverter from schrodinger couldn't be executed.")
        logging.info("The error is in the command ' {} '".format(command2call2))
        logging.shutdown()
        sys.exit("Program terminated due to the error:\n{}".format(error_message))
    # Let's generate the template.
    command2call2 = ploprottemp_command.format(ligand_filename_mae)
    try:
        ploprottemp_output = check_output(command2call2.split(), stderr=STDOUT, cwd=ploprottemp_wd)
    except CalledProcessError as error_message:
        if out:
            print "The PlopRotTemp program couldn't be execute. The program will be terminated."
            logging.critical("ERROR: The PlopRotTemp program couldn't be executed.")
            logging.info("The error is in the command ' {} '".format(command2call2))
            logging.shutdown()
            sys.exit("Program terminated due to the error:\n{}".format(error_message))
        else:
            logging.error(" - ERROR: The command ' {} ' couldn't be executed. Skipping system".format(command2call2))
    else:
        if "Removing Intermediate File:" not in ploprottemp_output:
            logging.error(" - The PlopRotTemp.py hasn't finished correctly, so the template and/or the rotamer "
                          "library may be missing.")
            logging.info(" - This system will be discontinued.")
            return ""
    template_filename = ""
    if args.debug:
        print command2call2
    for name4file in os.listdir(ploprottemp_wd):
        if args.debug:
                print name4file
        if fnmatch.fnmatch(name4file, "???"):
            template_filename = template_folder + name4file.split(os.sep)[-1] + "z"
            initial_name_temp = ploprottemp_wd + name4file.split(os.sep)[-1]
            move(initial_name_temp, template_filename)
        elif fnmatch.fnmatch(name4file, "*.rot.assign"):
            initial_name_rotlib = ploprottemp_wd + name4file
            with open(initial_name_rotlib, 'r') as filein:
                # This checks whether the rotamer library is empty or not, sometimes
                # ploprottemp generates libraries with just the header.
                number_of_lines = len(filein.readlines())
                if number_of_lines <= 1:
                    logging.info("WARNING: The rotamer library generated by PlopRotTemp is empty, removing it.")
                    os.remove(initial_name_rotlib)
                else:
                    destination_file = rotamer_library_folder + name4file.split(os.sep)[-1]

                    logging.info("The library of rotamers has been correctly generated and is: {}".format(
                        destination_file))
                    move(initial_name_rotlib, destination_file)
    rmtree(ploprottemp_wd)
    return template_filename


def split_complex(filename, warnings):
    with open(filename, 'r') as complex_text:
        ligand = ""
        receptor = ""
        for line in complex_text:
            if args.debug:
                print filename
            if "ATOM" in line or "HETATM" in line:
                if line[21] in [args.ligand_chain.upper(), args.ligand_chain.lower()]:
                    ligand += line
            elif line == "TER\n" and ligand:
                ligand += line
            else:
                receptor += line
    if ligand:
        logging.info(" - Extracting the ligand from the complex.")
        new_ligand_filename = new_general_subfolder + new_folder_name + "_ligand.pdb"
        new_complex_filename = filename
        with open(new_ligand_filename, 'w') as new_ligand_file:
            new_ligand_file.write(ligand)
            # In this case we don't really need the receptor in a separated file since we already have the complex.
            # receptor_filename = new_general_subfolder + new_folder_name + "_receptor.pdb"
            # with open(receptor_filename, 'w') as receptor_file:
            #     receptor_file.write(receptor)
    else:
        # If the program hasn't found the ligand chain it won't generate the files
        logging.info(" - There's nothing in chain Z for the file {}.".format(filename))
        logging.warning(" -WARNING: The procedure for the folder {} will be interrupted from now on.".format(
            new_general_subfolder))
        warnings += 1
        new_complex_filename = ""
        new_ligand_filename = ""
    return new_complex_filename, new_ligand_filename, warnings


def compute_center_of_mass(lig_filename):
    with open(lig_filename, 'r') as filein:
        molecule_atoms_text = [l for l in filein if l.startswith("ATOM") or l.startswith("HETATM")]
    masses_sum = 0.0
    coordinates_sumatory = np.zeros(3)
    for atom_line in molecule_atoms_text:
        resname = atom_line[12:16].lower()
        if resname in atomic_table_weights.keys():
            atom_mass = atomic_table_weights[resname]
        else:
            resname = resname.strip()
            if resname in atomic_table_weights.keys():
                atom_mass = atomic_table_weights[resname]
            else:
                if resname[:2] in atomic_table_weights.keys():
                    atom_mass = atomic_table_weights[resname[:2]]
                elif resname[0] in atomic_table_weights.keys():
                    atom_mass = atomic_table_weights[resname[0]]
                else:
                    print "The molecule has an atom not present in the atomic_weights table."
                    print "The atom is: {}".format(resname)
                    return False
        coordinates = np.asarray([float(x) for x in atom_line[30:54].split()])
        coordinates_sumatory += coordinates * atom_mass
        masses_sum += atom_mass
    center_of_mass = coordinates_sumatory / masses_sum

    return "{0[0]:.4f}, {0[1]:.4f}, {0[2]:.4f}".format(center_of_mass)


def check_previous_next(prev_element, next_element, current_element, n, reset):
    # if args.debug:
    #     print type(n), n, type(reset), reset
    if prev_element and prev_element == "TER":
        atom_id = '"{}:{}:{}"'.format(current_element[21], current_element[22:26].strip(),
                                      current_element[12:16].replace(" ", "_"))
        n = 0
    elif next_element and next_element == "TER":
        atom_id = '"{}:{}:{}"'.format(current_element[21], current_element[22:26].strip(),
                                      current_element[12:16].replace(" ", "_"))
        n = 0
    elif (n % reset) == 0:
        if args.debug:
            print 'hereh'
        try:
            atom_id = '"{}:{}:{}"'.format(current_element[21], current_element[22:26].strip(),
                                          current_element[12:16].replace(" ", "_"))
        except IndexError:
            print current_element
            sys.exit("Bad terminations")
        n = 0
    else:
        n += 1
        atom_id = False
    return n, atom_id


def obtain_constraints_from_pdb(pdb_filename, every, constraint, atoms2restrain):
    header = '    \n{0:6}{{ "type" : "constrainAtomToPosition", "springConstant":{1},' \
             ' "equilibriumDistance": 0.0, "constrainThisAtom":'.format(" ", constraint)
    constraints_text = ""
    with open(pdb_filename, 'r') as pdb_file:
        pdb_text = [lin for lin in pdb_file if
                    lin.startswith("TER") or ((lin[21] != "Z" and lin[12:16] in atoms2restrain) and
                                              (lin.startswith("ATOM") or lin.startswith("HETATM")))]
    counter = 0
    first = True
    if args.debug:
        print pdb_filename
        print every
        print constraint
        print atoms2restrain
    for index, element in enumerate(pdb_text):
        if args.debug:
            print element
        if element.strip() == "TER":
            continue
        else:
            if first:
                if pdb_text[index - 1] == "TER" or pdb_text[index + 1] == "TER":
                    print "Review the file {}. The initial residue from the first chain followed or preceded" \
                          " by a TER mark."
                    return False
                else:
                    first = False
                    constraints_text += header
                    constraints_text += '"{}:{}:{}" }}'.format(element[21], element[22:26].strip(),
                                                               element[12:16].replace(" ", "_"))
                    counter += 1
            else:
                # if args.debug:
                #     print 'a',
                if 0 < index < len(pdb_text) - 1:
                    counter, atom_id = check_previous_next(pdb_text[index - 1], pdb_text[index + 1],
                                                           element, counter, every)
                elif index == 0:
                    counter, atom_id = check_previous_next([], pdb_text[index + 1], element, counter, every)
                else:
                    counter, atom_id = check_previous_next(pdb_text[index - 1], [], element, counter, every)
                if counter == 0:
                    counter += 1
                if atom_id:
                    constraints_text += ',\n{0:6}{{ "type": "constrainAtomToPosition", "springConstant": {1}, ' \
                                        '"equilibriumDistance": 0.0, "constrainThisAtom":{2} }}'.format(" ", constraint,
                                                                                                        atom_id)
                else:
                    continue
    if not constraints_text:
        print "The constraints haven't been created for file {}".format(pdb_filename)
        return False
    else:
        constraints_text += '\n'
        return constraints_text


def obtain_current_values(template_keywords, complex_complete_path, warnings, errors, ligand_complete_path):
    keywords_values = {}
    for keyword in template_keywords:
        if search(".*constraints", keyword, IGNORECASE):
            if args.debug:
                print "file4pele: ", complex_complete_path
            constraints = obtain_constraints_from_pdb(complex_complete_path, args.every, args.constraint,
                                                      args.atoms2conStraint)
            if not constraints:
                print "Couldn't generate the constraints for file {}".format(complex_complete_path)
                logging.error("  ERROR: Couldn't generate the constraints for file {}".format(complex_complete_path))
                logging.info(" This system will be discontinued since constraints couldn't be generated.")
                errors += 1
                return False, warnings, errors
            # obtain constraints from a pdb file
            keywords_values[keyword] = constraints
        elif search("center_*of_*mass", keyword, IGNORECASE):
            mass_center = compute_center_of_mass(ligand_complete_path)
            if not mass_center:
                logging.warning("  WARNING: This system will be discontinued. Couldn't compute the center of mass.")
                logging.info("INFO: to solve this problem talk with he developer and provide the ligand file.")
                warnings += 1
                return False, warnings, errors
            keywords_values[keyword] = mass_center
        elif search("input.*", keyword, IGNORECASE):
            keywords_values[keyword] = complex_complete_path.split('/')[-1]
        elif search("license.*", keyword, IGNORECASE):
            keywords_values[keyword] = args.pele_license
        elif search("system.*", keyword, IGNORECASE):
            keywords_values[keyword] = new_folder_name
        else:
            print "The keyword '{}' isn't a valid one".format(keyword)
            logging.warning("  WARNING: This system will be discontinued. The keyword {} isn't a valid one".format(
                keyword))
            logging.info("INFO: Check your keyword if it should be valid talk with he developer and provide "
                         "the template file.")
            warnings += 1
            return False, warnings, errors
            # Every time a new keyword appears a new search should be added.
    return keywords_values, warnings, errors


def check_ligand(lig_filename):
    changes = False
    with open(lig_filename, 'r') as lig_file:
        peptidic_ligand = False
        new_lig = ""
        for l in lig_file:
            if l.startswith("ATOM"):
                peptidic_ligand = True
            elif l.startswith("HETATM"):
                if l[21] != "Z":
                    changes = True
                    l = l[:21] + "Z" + l[22:]
                if search(r'<.>', l[17:20]) or search(r'UNK', l[17:20]):
                    changes = True
                    l = l[:17] + "LIG" + l[20:]
                if peptidic_ligand:
                    message = "WARNING: This ligand has peptidic and non peptidic residues. It will be skipped.\n" \
                              "Remember that the peptide-like ligands should be considered as one single ligand, " \
                              "with only one residue."
                    logging.info(message)
                    print "Check the system {} its ligand is peptide-like and it has several residues.".format(
                        lig_filename)
                    continue
            new_lig += l
    if changes:
        # print new_lig
        with open(lig_filename, 'w') as lig_file:
            lig_file.write(new_lig)
    if args.debug:
        print lig_filename
    command2call2 = mutations_program_command.format(lig_filename) + "-opdb {}".format(lig_filename)
    try:
        check_output(command2call2.split())
    except CalledProcessError as e:
        print lig_filename
        # print a
        if args.debug:
            print command2call2
        logging.critical("ERROR: the program can't call the mutations_program.py")
        logging.info("Terminating the program.")
        logging.shutdown()
        sys.exit("The program can't execute the mutations_program.py")
    return peptidic_ligand


def check_mutations_program_output(command, filename, errors_counter):
    command_call = command.format(filename)
    call_output = check_output(command_call.split(), stderr=STDOUT)
    file2use = ""
    # We want to use the file generated by the mutations program since it will have the correct format for PELE.
    if "Writing the structure to" not in call_output:
        error_filename = subfolders_path + "receptor_preparation_error_log.txt"
        logging.error(
            " - ERROR: The mutations program hasn't been able to prepare the complex file for the file.\n"
            "   More information about this error in the file {}".format(error_filename))
        errors_counter += 1
        with open(error_filename, 'w') as error_file:
            error_file.write(call_output)
    else:
        file2use = filename.split('.pdb')[0] + "_processed.pdb"
        logging.info(" - The file ready for pele it's called: {0}".format(file2use))
    return file2use


parser = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
parser.add_argument("-input_files", "-input", required=True, nargs="+",
                    help=help_descriptions.input_files_desc)
parser.add_argument("-receptor", default=enviroment_parameters.receptor_file_default,
                    help=help_descriptions.receptor_desc)
parser.add_argument("-subfolders_path", default=enviroment_parameters.subfolders_path_default,
                    help=help_descriptions.subfolder_path_desc)
parser.add_argument("-log_file", default=enviroment_parameters.log_file_default,
                    help=help_descriptions.log_file_desc)
parser.add_argument("-pele_folders", default=enviroment_parameters.pele_folders,
                    help=help_descriptions.pele_folder_desc)
parser.add_argument("-debug", action="store_true", help=help_descriptions.debug_desc)
parser.add_argument("-not_interactive", action="store_true", help=help_descriptions.not_interactive_desc)
parser.add_argument("-schrodinger_path",
                    default=enviroment_parameters.schrodinger_path, help=help_descriptions.schrodinger_path_desc)
parser.add_argument("-plop_path", default=enviroment_parameters.plop_path, help=help_descriptions.plop_path_desc)
parser.add_argument("-conf_template", "-conf_file_template",
                    default=enviroment_parameters.conformational_template,
                    help=help_descriptions.template_desc)
parser.add_argument("-pele_license", default=enviroment_parameters.pele_license_path,
                    help=help_descriptions.pele_license_desc)
parser.add_argument("-every", "-fix_every_x_atoms", default=enviroment_parameters.default_every,
                    type=int, help=help_descriptions.every_desc)
parser.add_argument("-constraint", "-constraint_strength", default=enviroment_parameters.constraints_strength,
                    help=help_descriptions.constraint_desc)
parser.add_argument("-atoms2conStraint", default=enviroment_parameters.atoms2apply_constraints_default,
                    nargs='+', help=help_descriptions.atoms2constraint_desc)
parser.add_argument("-mutations_program_path", default=enviroment_parameters.mutations_program_path,
                    help=help_descriptions.mutations_program_path_desc)
parser.add_argument("-obc_param_generator", default=enviroment_parameters.obc_param_generator_path,
                    help=help_descriptions.obc_param_generator_desc)
parser.add_argument("-ligand_chain", default=enviroment_parameters.ligand_chain,
                    help=help_descriptions.ligand_chain_desc)
parser.add_argument("-no_templates", action="store_true", help=help_descriptions.no_templates)
# parser.add_argument("-sub_template", default="./submit_template.sh")
args = parser.parse_args()

# The program will always generate a log file.
logging.basicConfig(filename=args.log_file, format="%(message)s", level=logging.INFO, filemode="w")
logging.info("{} : Program starting".format(datetime.datetime.now().strftime("%Y-%m-%d %H:%M")))

# The first step to do is to check if the arguments are in the right format:
# the input files and the receptor should be either in .pdb or .mae formats,
# to check for this a pattern will be used.

# These are the commands that will be executed during the program, they change depending
# on where the program is being executed AZ or BSC
# Commands AZ
# This line is mandatory only for AZ, as the import
# The first thing is to load the schrodinger module
# module("load", "schrodinger/2016.01")
# Then we load the commands from the constant values depending on where we are.
# schrodinger_mae2pdb_convert_command = "pdbconvert -imae {} -opdb {}"
# schrodinger_pdb2mae_convert_command = "pdbconvert  -ipdb {} -omae {}"
# ploprottemp = "{}/utilities/python {}".format(args.schrodinger_path, args.plop_path)
# ploprottemp_command = ploprottemp + " {} -mae_charges=no -mtor=5 -g=30 -clean=yes"
# mutations_program_command = "python " + args.mutations_program_path + \
#                             " -ipdb {} -make_unique Z -gaps_ter "
# Commands BSC
schrodinger_converter = "{}/utilities/pdbconvert ".format(args.schrodinger_path)
schrodinger_mae2pdb_convert_command = schrodinger_converter + " -imae {} -opdb {}"
schrodinger_pdb2mae_convert_command = schrodinger_converter + " -ipdb {} -omae {}"
ploprottemp = "{}/utilities/python {}".format(args.schrodinger_path, args.plop_path)
ploprottemp_command = ploprottemp + " {} -mae_charges=no -mtor=5 -g=30 -clean=yes"
mutations_program_command = "python " + args.mutations_program_path + \
                            " -ipdb {} -make_unique Z -gaps_ter "

mutations_program_command_receptor = "python " + args.mutations_program_path + \
                            " -ipdb {} -gaps_ter "
obc_param_generator = "python {}".format(args.obc_param_generator)
obc_param_command = obc_param_generator + " {}"

command_first_execution = {"ploprottemp": True, 'mae2pdb_convert': True, 'pdb2mae_convert': True,
                           'mutations_program': True, 'obc_param_gen': True}

# Set up a counter for non-critical errors and warnings to do a simple summary in the log file.
errors_counter = 0
warnings_counter = 0

# check if the path from the option subfolder_path, ends in the system separator otherwise it adds it,
# by default the program creates the subfolders in the directory where the program is executed.
if args.subfolders_path[-1] != os.sep:
    subfolders_path = args.subfolders_path + os.sep
else:
    subfolders_path = args.subfolders_path
if not os.path.isdir(args.subfolders_path):
    if args.not_interactive:
        logging.critical("ERROR: The path to create the subfolders doesn't exist, it should be created previously "
                         "by the user. The program will be terminated.")
        logging.shutdown()
        sys.exit("In the not interactive mode the user should have created previously the general folder where the new"
                 "folders should be created.\nTerminating the program")
    else:
        print "The path to create the subfolders doesn't exist"
        answer = raw_input("Do you want to create the folder {}? Y/n\n".format(args.subfolders_path))
        if search("n.*", answer, IGNORECASE):
            answer = raw_input("Do you want to create and use another path? y/[N]?\n")
            if search("n", answer, IGNORECASE) or answer == "":
                logging.critical("ERROR: The path to create the subfolders doesn't exist\n"
                                 "The user has chosen to terminate the program")
                sys.exit("The program will be terminated.")
            else:
                new_subfolders_path = raw_input("Please introduce the path where the folders should be generated:\n")
                print "Creating the folder {}".format(new_subfolders_path)
                os.mkdir(new_subfolders_path)
                current_directory = os.getcwd()
                args.subfolders_path = current_directory + new_subfolders_path
                logging.info("The folder {} has been created and the new folders will be generated in it.")
        elif search("y.*", answer, IGNORECASE) or answer == "":
            os.mkdir(args.subfolders_path)
            print "Creating the folder {}".format(args.subfolders_path)
            logging.info("The folder {} has been created and the new folders will be generated in it.")

# check the format of the receptor file if it exists, if it isn't valid the program is terminated.
receptor_text = ""
if args.receptor:
    format_ok = findall(accepted_formats, args.receptor)
    if not format_ok or len(format_ok) > 1:
        logging.critical("ERROR: The format of the receptor file isn't valid.\n\Terminating the program.")
        sys.exit("ERROR: The format of the receptor file isn't valid.\n\Terminating the program.")
    else:
        logging.info("The receptor file specified is: {}\n".format(args.receptor))
        receptor_format = format_ok[0]
    form_complexes = True
    logging.info("INFO: The input files will be treated as single ligands and the receptor "
                 "file will be used to form all the complexes\n")
    is_mae_file = search("(.*)\.mae", args.receptor)
    if is_mae_file:
        print "The receptor file will be converted to .pdb format using schrodinger's converter."
        logging.info("The receptor file will be converted to .pdb format using schrodinger's converter."
                     " This new file will be used as the receptor.")
        receptor_pdb = is_mae_file.group(1) + ".pdb"
        command2call = schrodinger_mae2pdb_convert_command.format(args.receptor, receptor_pdb)
        try:
            check_call(command2call.split())
        except CalledProcessError as error_message:
            print "The pdbconverter of maestro failed to when being execute. The program will be terminated."
            logging.critical("ERROR: The pdbconverter from schrodinger couldn't be executed.")
            logging.info("The error is in the command ' {} '".format(command2call))
            logging.shutdown()
            sys.exit("Program terminated due to the error:\n{}".format(error_message))
        args.receptor = receptor_pdb
    # This option should be chosen only if the user has specified a receptor file.
    # If a receptor is given copy it to the new folder.
    if os.sep in args.receptor:
        receptor_copy = subfolders_path + args.receptor.split(os.sep)[-1]
    else:
        receptor_copy = subfolders_path + args.receptor
    if os.path.isfile(receptor_copy):
        logging.info(" - INFO: The receptor file it's already in the new subfolder,"
                     " the receptor will be renamed")
        pattern4new_receptor = search("(.*)(\.mae|\.pdb)", receptor_copy)
        if pattern4new_receptor is None:
            # This shouldn't happen ever since a similar pattern has been checked previously...
            logging.critical("There's a problem in the code, tell the developer code L281")
            logging.shutdown()
            sys.exit("You got somewhere where it should be impossible to get. Code L281")
        else:
            new_receptor_name = "{0}_1{1}".format(pattern4new_receptor.group(1), pattern4new_receptor.group(2))
            receptor_copy = new_receptor_name
            logging.info("INFO: The receptor file in the folder {} is named {}".format(subfolders_path,
                                                                                       new_receptor_name))
    copyfile(args.receptor, receptor_copy)
    receptor_filename = receptor_copy

    logging.info(" - Calling the 'mutations_program.py' to format the receptor file.")
    processed_receptor_filename = check_mutations_program_output(mutations_program_command_receptor,
                                                                 receptor_copy, errors_counter)
    if not processed_receptor_filename:
        logging.critical("")
        logging.shutdown()
        sys.exit("There's been a problem while processing the receptor file with the mutations program.\n"
                 "Check the log file {0} for more information about the problem.".format(args.log_file))
    with open(processed_receptor_filename, 'r') as receptor_file:
        for line in receptor_file:
            if line.startswith("ATOM") or line.startswith("HETATM") or line.startswith("TER"):
                receptor_text += line

else:
    form_complexes = False

# check if the input files are in the right format, if any of them isn't it will be skipped
input_files = []
number_of_skipped_files = 0
heading = "The following files don't have the right extension (the program will skip them):"
# This loop iterates over the filenames and discards those that don't have the right extension.
for filename in args.input_files:
    format_ok = findall(accepted_formats, filename)
    if not format_ok or len(format_ok) > 1:
        if number_of_skipped_files == 0:
            number_of_skipped_files += 1
            line = heading + " {}. {}".format(number_of_skipped_files, filename)
        else:
            line = " {}. {}".format(number_of_skipped_files, filename)
        logging.info(line)
    else:
        input_files.append(filename)
if input_files:
    if number_of_skipped_files == 0:
        logging.info("All the input files have the right format.")
    logging.info("The input files are:\n{}".format("\n".join([filename for filename in input_files])))
else:
    print args.input_files
    logging.critical("\nERROR: None of the files specified in the input has the right format."
                     "\nTerminating the program.")
    logging.info("The input files are {}".format("\n".join([filename for filename in input_files])))
    logging.shutdown()
    sys.exit("ERROR: No valid input file.\nTerminating the program.")

# Check the configuration file template to look for the parameters to generate.
if search("none", args.conf_template, IGNORECASE) is None:
    with open(args.conf_template, 'r') as template_file:
        logging.info(" - Creating the configuration file Template.")
        template_text = "".join(template_file.readlines())
        keywords_in_the_template = set(pattern.group(1) for pattern in finditer("\$\{*(\w*_*w*)\}?", template_text))
        solvent_type = search(r'"solventType" : "(.*)",', template_text)
    if solvent_type is None:
        logging.critical("ERROR: The template doesn't specify the solvent type PELE won't work.")
        logging.info("Terminating the program")
        logging.shutdown()
        sys.exit("Terminating the program.\nThe configuration file doesn't specify the solvent type.")
    else:
        solvent_type = solvent_type.group(1).lower()
    generate_configuration_file_template = True
else:
    logging.info("The program won't generate any configuration file. Because no template has been given.")
    print "No configuration file will be generated."
    solvent_type = ""
    generate_configuration_file_template = False
    keywords_in_the_template = {}
    template_text = ""

# This variable will store the name of the configuration files created.
configuration_files_names = []

# This huge for loop takes care of all the preparation for each system. From creating the folders
# to generate the configuration file needed for PELE, it also
for filename in input_files:
    logging.info("Working with file: {}".format(filename))
    minimum_filename = filename.split(os.sep)[-1]
    new_folder_name = ".".join(minimum_filename.split(".")[:-1])  # With this the extension of the file is
    # removed while keeping all posible . in the name.
    new_general_subfolder = subfolders_path + new_folder_name + os.sep
    exists_already = False
    # The next step is to create a folder for each file, these subfolders will be generated in the
    # directory specified by the option subfolder_path and copy the file.
    # logging.info(" - Creating the folder {}".format(new_general_subfolder))
    createfolder(new_general_subfolder)
    # This block also generates all the folders and links needed to launch a PELE simulations
    # in the new folders. If the folders exist from previous runs they'll be kept
    datalocal_folder = new_general_subfolder + "DataLocal" + os.sep
    rotamerlibs_folder = datalocal_folder + "LigandRotamerLibs" + os.sep
    templates_folder = datalocal_folder + "Templates" + os.sep
    opls_folder = templates_folder + "OPLS2005" + os.sep
    hetero_folder = opls_folder + "HeteroAtoms" + os.sep
    output_folder = new_general_subfolder + "output_{0}".format(solvent_type)
    pele_data = args.pele_folders + os.sep + "Data"
    link2data = new_general_subfolder + "Data"
    pele_documents = args.pele_folders + os.sep + "Documents"
    link2documents = new_general_subfolder + "Documents"
    createfolder(output_folder)
    if args.no_templates:
        logging.info(" - The option no_templates has been chosen, the program will assume they already exist.")
    else:
        logging.info(" - Creating the subfolder DataLocal and all its subfolders.")
        createfolder(datalocal_folder)
        createfolder(rotamerlibs_folder)
        createfolder(templates_folder)
        createfolder(opls_folder)
        createfolder(hetero_folder)
        createsymboliclink(pele_data, link2data)
        createsymboliclink(pele_documents, link2documents)
    # Links and subfolders created.

    # Now the program copies the input file into the newly created folder.
    file_copy = new_general_subfolder + minimum_filename
    if args.debug:
        print filename
        print file_copy
    copyfile(filename, file_copy)
    # If the file is in .mae format it'll be converted to .pdb format to be able to do the checks
    # and modifications needed in a simpler way.
    is_mae_file = search("(.*)\.mae", file_copy)
    if is_mae_file:
        #  The input file has .mae format so it should be transformed to .pdb format
        file_in_pdb_format = is_mae_file.group(1) + ".pdb"
        command2call = schrodinger_mae2pdb_convert_command.format(file_copy, file_in_pdb_format)
        file_copy = file_in_pdb_format  # Updating the variable containing the name of the file to work with
        try:
            check_call(command2call.split())
        except CalledProcessError as error_message:
            print "The pdbconverter of maestro failed to when being execute. The program will be terminated."
            logging.critical("ERROR: The pdbconverter from schrodinger couldn't be executed.")
            logging.info("The error is in the command ' {} '".format(command2call))
            logging.shutdown()
            sys.exit("Program terminated due to the error:\n{}".format(error_message))
    # If no receptor is specified the program assumes the original file is a complex and will try to generate
    # a _receptor.pdb file and a _ligand.pdb file extracting the chain Z from the original file.
    if args.no_templates:
        no_need4template = True
        existing_templates = glob(hetero_folder + "???z")
        if existing_templates:
            ligand_template_filename = existing_templates[0]
        else:
            logging.warning("WARNING: There are no pre-existing templates "
                            "for this system so it will be discontinues.")
            warnings_counter += 1
            continue
        # print new_general_subfolder+ "*_complex_processed.pdb"
        if form_complexes:
            complex_filename = glob(new_general_subfolder + "*_complex_processed.pdb")[0]
            # file4pele = complex_filename.split('/')
            ligand_filename = file_copy
        else:
            ligand_filename = file_copy
            complex_filename = check_mutations_program_output(mutations_program_command, file_copy, errors_counter)
            complex_filename, ligand_filename, warnings_counter = split_complex(complex_filename, warnings_counter)
            if not complex_filename and not ligand_filename:
                # The error message is generated in the split_complex function
                continue
    else:
        if form_complexes:
            if args.debug:
                print 0, 'uuppss'
            ligand_filename = file_copy
            no_need4template = check_ligand(ligand_filename)
            logging.info(" - Generating the complex file.")
            complex_text = receptor_text
            with open(ligand_filename, 'r') as ligand_file:
                for line in ligand_file:
                    if line.startswith("ATOM") or line.startswith("HETATM") or line.startswith("TER"):
                        complex_text += line
            if complex_text:
                complex_filename = new_general_subfolder + new_folder_name + "_complex.pdb"
                with open(complex_filename, 'w') as complex_file:
                    complex_file.write(complex_text)
            else:
                # If the code gets here is due to the fact that the receptor and the ligand files are empty so
                # it shouldn't continue.
                logging.critical("There's a problem in the code, tell the developer code L446")
                logging.shutdown()
                print "BU!! NOT WORKING!"  # TODO:Change this message to something more serious
                sys.exit("See what's happening..LINE 277 ")
        else:
            if args.debug:
                print 'here'
            complex_filename, ligand_filename, warnings_counter = split_complex(file_copy, warnings_counter)
            if not complex_filename and not ligand_filename:
                # The error message is generated in the split_complex function
                continue
            no_need4template = check_ligand(ligand_filename)

        # block calling the mutations program to generate the preprocessed
        # .pdb file
        logging.info(" - Calling the 'mutations_program.py' to format the complex file.")
        command2call = mutations_program_command.format(complex_filename)
        file_preparation_output = check_output(command2call.split(), stderr=STDOUT)
        # We want to use the file generated by the mutations program since it will have the correct format for PELE.
        if "Writing the structure to" not in file_preparation_output:
            error_filename = new_general_subfolder + new_folder_name + "_preparation_error_log.txt"
            logging.error(
                " - ERROR: The mutations program hasn't been able to prepare the complex file for the file.\n"
                "   More information about this error in the file {}".format(error_filename))
            errors_counter += 1
            with open(error_filename, 'w') as error_file:
                error_file.write(file_preparation_output)
            complex_filename = complex_filename.split('/')[-1]
            logging.info(" - The original complex will be used: {}".format(complex_filename))
            continue
        else:
            complex_filename = complex_filename.split('.pdb')[0] + "_processed.pdb"
            logging.info(" - The file ready for pele it's called: {}".format(complex_filename))
            # The configuration file and this file will be in the same folder thus we just need the name of
            # the complex and not the whole path.
        if ".pdb" not in ligand_filename:
            print "ligand_filename:", ligand_filename
            logging.critical("There's a problem in the code, tell the developer code L354")
            logging.shutdown()
            sys.exit("Programming error in here! The ligand isn't in .pdb format")
            # Now that we've made sure the ligand is in chain Z and it has a normal name or LIG as the residue name
            # we convert it to .mae format, so we can create the template. Unless the ligand it's a peptide in
            # which case we don't need to generate a template.
    if not no_need4template:
        ligand_template_filename = create_template_and_rotamerlib(ligand_filename, hetero_folder, rotamerlibs_folder,
                                                                  command_first_execution['ploprottemp'])
        if ligand_template_filename:
            command_first_execution['ploprottemp'] = False
        else:
            logging.info(" - The template hasn't been generated for this system. It'll be discotinued")
            errors_counter += 1
            continue
        if not ligand_template_filename:
            errors_counter += 1
            continue
            # generating the solvent parameter for the ligand if the desired solvent is OBC.
    if solvent_type == "obc":
        logging.info(" - Checking for the existence of the OBC parameters.")
        original_obc_param = args.pele_folders + os.sep + "Data/OBC/solventParamsHCTOBC.txt"
        copy_obc_folder = datalocal_folder + "OBC" + os.sep
        copy_obc_param = copy_obc_folder + "solventParamsHCTOBC.txt"
        if os.path.isdir(copy_obc_folder) and os.path.isfile(copy_obc_param):
            # Checks if the folder and file already exist otherwise the program creates them.
            logging.info(" - The parameters already exist.")
        else:
            logging.info(" - Generating the solvent parameters.")
            command2call = obc_param_command.format(ligand_template_filename)
            # print command2call
            try:
                cmd_output = check_output(command2call.split(), stderr=STDOUT)
            except CalledProcessError as error_message:
                print "The program failed to execute the OBC script. The program will be terminated."
                logging.critical("ERROR: The script to generate the OBC parameters couldn't be executed.")
                logging.info("The error is in the command ' {} '".format(command2call))
                logging.shutdown()
                sys.exit("Program terminated due to the error:\n{}".format(error_message))
            obc_command_output_file = ligand_template_filename + "_OBCParams.txt"
            try:
                os.mkdir(copy_obc_folder)
            except OSError as e:
                if search(r"exists", e[1]):
                    pass
                else:
                    print "There's been a problem creating the OBC folder, review it.", e
            copyfile(original_obc_param, copy_obc_param)
            if os.path.isfile(obc_command_output_file):
                with open(obc_command_output_file, 'r') as obc_template_file:
                    obc_text = "".join(obc_template_file.readlines()) + "\n"
                with open(copy_obc_param, 'a') as obc_param_file:
                    obc_param_file.write(obc_text)
                os.remove(obc_command_output_file)
            else:
                logging.error(" - ERROR: The OBC parameters required couldn't be generated.")
                errors_counter += 1
                logging.info(" INFO: This system will be discontinued.")
                continue
    # This block creates the configuration file into the folder.
    if generate_configuration_file_template:
        keywords_values, warnings_counter, errors_counter = obtain_current_values(keywords_in_the_template,
                                                                                  complex_filename, warnings_counter,
                                                                                  errors_counter, ligand_filename)
        if not keywords_values:
            continue
        template = Template(template_text)
        try:
            new_conf_file_text = template.substitute(keywords_values)
        except (KeyError, ValueError) as e:
            logging.critical("ERROR: the configuration file template isn't able to obtain all the needed values.")
            logging.critical("The program has been terminated.")
            logging.shutdown()
            print "Programing error. Talk with the developer. Code L549"
            if args.debug:
                print keywords_in_the_template
                print keywords_values.keys()
            print e
            sys.exit("Error when creating the configuration file, missing keywords.")
        else:
            new_conf_file_filename = new_general_subfolder + new_folder_name + "_{0}".format(solvent_type) + ".conf"
            with open(new_conf_file_filename, 'w') as new_conf_file:
                new_conf_file.write(new_conf_file_text)
        configuration_files_names.append(new_conf_file_filename)

# Now we have to create a file to submit the jobs. The file will depend on where they want to be run, so
# we should use a template, also there are some requirements that change depending on BSC/AZ
# In AZ the nodes have 12 physical cores so all the jobs should be  multiple of 24 or 12
# with open(args.sub_template, 'r') as sub_template_file:
#     sub_template_text = "".join(sub_template_file.readlines())

print "Finished Correctly."
logging.info("{} : Program finished normally with {} warnings and {} non-critical errors.".format(
    datetime.datetime.now().strftime("%Y-%m-%d %H:%M"), warnings_counter, errors_counter))
logging.shutdown()
