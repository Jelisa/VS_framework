#!usr/bin/python

# TODO: Change the call to something that grabs the outputs to process them
# TODO: Check the calls and skip a system if it fails at some point, but if the failure is due to the program path exit.

""""
This program prepares the complexes and files to launch PELE simulations.
author: Jelisa Iglesias
mail: jelisa.iglesias@bsc.es
"""

import datetime
import fnmatch
import logging
import os
import sys
from argparse import ArgumentParser
from re import search, findall, finditer, IGNORECASE
from shutil import copyfile, rmtree, move
from string import Template
from subprocess import check_output, CalledProcessError, check_call, STDOUT
from tempfile import mkdtemp
import numpy as np
from modules import module

import help_descriptions
from constant_values import atomic_table_weights, accepted_formats


def create_template_and_rotamerlib(initial_pdb, template_folder, rotamer_library_folder, out):
    ploprottemp_wd = mkdtemp(prefix="plop_exec_")
    ploprottemp_wd += os.sep
    ligand_filename_mae = ploprottemp_wd +  initial_pdb.split(os.sep)[-1].split(".pdb")[0] + ".mae"
    command2call2 = schrodinger_pdb2mae_convert_command.format(initial_pdb, ligand_filename_mae)
    try:
        check_call(command2call2.split())
    except CalledProcessError as error_message:
        print "The pdbconverter of maestro failed to when being execute. The program will be terminated."
        logging.critical("ERROR: The pdbconverter from schrodinger couldn't be executed.")
        logging.info("The error is in the command ' {} '".format(command2call2))
        logging.shutdown()
        sys.exit("Program terminated due to the error:\n{}".format(error_message))
    # Let's generate the template.
    command2call2 = ploprottemp_command.format(ligand_filename_mae)
    try:
        ploprottemp_output = check_output(command2call2.split(), stderr=STDOUT, cwd=ploprottemp_wd)
    except CalledProcessError as error_message:
        if out:
            print "The PlopRotTemp program couldn't be execute. The program will be terminated."
            logging.critical("ERROR: The PlopRotTemp program couldn't be executed.")
            logging.info("The error is in the command ' {} '".format(command2call2))
            logging.shutdown()
            sys.exit("Program terminated due to the error:\n{}".format(error_message))
        else:
            logging.error(" - ERROR: The command ' {} ' couldn't be executed. Skipping system".format(command2call2))
    else:
        if "Removing Intermediate File:" not in ploprottemp_output:
            logging.error(" - The PlopRotTemp.py hasn't finished correctly, so the template and/or the rotamer "
                          "library may be missing.")
            logging.info(" - This system will be discontinued.")
            return ""
    template_filename = ""
    if args.debug:
        print command2call2
    for name4file in os.listdir(ploprottemp_wd):
        if args.debug:
                print name4file
        if fnmatch.fnmatch(name4file, "???"):
            template_filename = template_folder + name4file.split(os.sep)[-1] + "z"
            initial_name_temp = ploprottemp_wd + name4file.split(os.sep)[-1]
            move(initial_name_temp, template_filename)
        elif fnmatch.fnmatch(name4file, "*.rot.assign"):
            initial_name_rotlib = ploprottemp_wd + name4file
            with open(initial_name_rotlib, 'r') as filein:
                # This checks whether the rotamer library is empty or not, sometimes
                # ploprottemp generates libraries with just the header.
                number_of_lines = len(filein.readlines())
                if number_of_lines <= 1:
                    logging.info("WARNING: The rotamer library generated by PlopRotTemp is empty, removing it.")
                    os.remove(initial_name_rotlib)
                else:
                    destination_file = rotamer_library_folder + name4file.split(os.sep)[-1]

                    logging.info("The library of rotamers has been correctly generated and is: {}".format(
                        destination_file))
                    move(initial_name_rotlib, destination_file)
    rmtree(ploprottemp_wd)
    return template_filename


def compute_center_of_mass(lig_filename):
    with open(lig_filename, 'r') as filein:
        molecule_atoms_text = [l for l in filein if l.startswith("ATOM") or l.startswith("HETATM")]
    masses_sum = 0.0
    coordinates_sumatory = np.zeros(3)
    for atom_line in molecule_atoms_text:
        resname = atom_line[12:16].lower()
        if resname in atomic_table_weights.keys():
            atom_mass = atomic_table_weights[resname]
        else:
            resname = resname.strip()
            if resname in atomic_table_weights.keys():
                atom_mass = atomic_table_weights[resname]
            else:
                if resname[:2] in atomic_table_weights.keys():
                    atom_mass = atomic_table_weights[resname[:2]]
                elif resname[0] in atomic_table_weights.keys():
                    atom_mass = atomic_table_weights[resname[0]]
                else:
                    print "The molecule has an atom not present in the atomic_weights table."
                    print "The atom is: {}".format(resname)
                    return False
        coordinates = np.asarray([float(x) for x in atom_line[30:54].split()])
        coordinates_sumatory += coordinates * atom_mass
        masses_sum += atom_mass
    center_of_mass = coordinates_sumatory / masses_sum

    return "{0[0]:.4f}, {0[1]:.4f}, {0[2]:.4f}".format(center_of_mass)


def check_previous_next(prev_element, next_element, current_element, n, reset):
    if args.debug:
        print type(n), n, type(reset), reset
    if prev_element and prev_element == "TER":
        atom_id = '"{}:{}:{}"'.format(current_element[21], current_element[22:26].strip(),
                                      current_element[12:16].replace(" ", "_"))
        n = 0
    elif next_element and next_element == "TER":
        atom_id = '"{}:{}:{}"'.format(current_element[21], current_element[22:26].strip(),
                                      current_element[12:16].replace(" ", "_"))
        n = 0
    elif (n % reset) == 0:
        if args.debug:
            print 'hereh'
        try:
            atom_id = '"{}:{}:{}"'.format(current_element[21], current_element[22:26].strip(),
                                          current_element[12:16].replace(" ", "_"))
        except IndexError:
            print current_element
            sys.exit("Bad terminations")
        n = 0
    else:
        n += 1
        atom_id = False
    return n, atom_id


def obtain_constraints_from_pdb(pdb_filename, every, constraint, atoms2restrain):
    header = '    \n{0:6}{{ "type" : "constrainAtomToPosition", "springConstant":{1},' \
             ' "equilibriumDistance": 0.0, "constrainThisAtom":'.format(" ", constraint)
    constraints_text = ""
    with open(pdb_filename, 'r') as pdb_file:
        pdb_text = [lin for lin in pdb_file if
                    lin.startswith("TER") or ((lin[21] != "Z" and lin[12:16] in atoms2restrain) and
                                              (lin.startswith("ATOM") or lin.startswith("HETATM")))]
    counter = 0
    first = True
    if args.debug:
        print pdb_filename
        print every
        print constraint
        print atoms2restrain
    for index, element in enumerate(pdb_text):
        if args.debug:
            print element
        if element.strip() == "TER":
            continue
        else:
            if first:
                if pdb_text[index - 1] == "TER" or pdb_text[index + 1] == "TER":
                    print "Review the file {}. The initial residue from the first chain followed or preceded" \
                          " by a TER mark."
                    return False
                else:
                    first = False
                    constraints_text += header
                    constraints_text += '"{}:{}:{}" }}'.format(element[21], element[22:26].strip(),
                                                               element[12:16].replace(" ", "_"))
                    counter += 1
            else:
                if args.debug:
                    print 'a',
                if 0 < index < len(pdb_text) - 1:
                    counter, atom_id = check_previous_next(pdb_text[index - 1], pdb_text[index + 1],
                                                           element, counter, every)
                elif index == 0:
                    counter, atom_id = check_previous_next([], pdb_text[index + 1], element, counter, every)
                else:
                    counter, atom_id = check_previous_next(pdb_text[index - 1], [], element, counter, every)
                if counter == 0:
                    counter += 1
                if atom_id:
                    constraints_text += ',\n{0:6}{{ "type": "constrainAtomToPosition", "springConstant": {1}, ' \
                                        '"equilibriumDistance": 0.0, "constrainThisAtom":{2} }}'.format(" ", constraint,
                                                                                                        atom_id)
                else:
                    continue
    if not constraints_text:
        print "The constraints haven't been created fo file {}".format(pdb_filename)
        return False
    else:
        constraints_text += '\n'
        return constraints_text


def check_ligand(lig_filename):
    changes = False
    with open(lig_filename, 'r') as lig_file:
        peptidic_ligand = False
        new_lig = ""
        for l in lig_file:
            if l.startswith("ATOM"):
                peptidic_ligand = True
            elif l.startswith("HETATM"):
                if l[21] != "Z":
                    changes = True
                    l = l[:21] + "Z" + l[22:]
                if search(r'<.>', l[17:20]) or search(r'UNK', l[17:20]):
                    changes = True
                    l = l[:17] + "LIG" + l[20:]
                if peptidic_ligand:
                    message = "WARNING: This ligand has peptidic and non peptidic residues. It will be skipped.\n" \
                              "Remember that the peptide-like ligands should be considered as one single ligand, " \
                              "with only one residue."
                    logging.info(message)
                    print "Check the system {} its ligand is peptide-like and it has several residues.".format(
                        lig_filename)
                    continue
            new_lig += l
    if changes:
        with open(lig_filename, 'w') as lig_file:
            lig_file.write(new_lig)
    command2call2 = mutations_program_command.format(lig_filename) + "-opdb {}".format(lig_filename)
    try:
        check_output(command2call2.split())

    except CalledProcessError as e:
        if args.debug:
            print command2call2
        logging.critical("ERROR: the program can't call the mutations_program.py")
        logging.info("Terminating the program.")
        logging.shutdown()
        sys.exit("The program can't execute the mutations_program.py")
    return peptidic_ligand


parser = ArgumentParser()
parser.add_argument("-input_files", "-input", required=True, nargs="+", help=help_descriptions.input_files_desc)
parser.add_argument("-receptor", default="", help=help_descriptions.receptor_desc)
parser.add_argument("-subfolders_path", default=".", help=help_descriptions.subfolder_path_desc)
parser.add_argument("-log_file", default="log.txt", help=help_descriptions.log_file_desc)
parser.add_argument("-pele_folders", default="/home/kqtw353/stay/external_software/PELErev12349",
                    help=help_descriptions.pele_folder_desc)
parser.add_argument("-debug", default=False, action="store_true", help=help_descriptions.debug_desc)
parser.add_argument("-not_interactive", default=False, action="store_true",
                    help=help_descriptions.not_interactive_desc)
parser.add_argument("-schrodinger_path",
                    default="/opt/az/schrodinger/schrodinger_suite/2016.03",
                    help=help_descriptions.schrodinger_path_desc)
parser.add_argument("-plop_path", default="/home/kqtw353/stay/work/PlopRotTemp/PlopRotTemp.py",
                    help=help_descriptions.plop_path_desc)
parser.add_argument("-conf_template", "-conf_file_template",
                    default="/home/kqtw353/stay/work/conformational_search_pele_template.conf",
                    help=help_descriptions.template_desc)
parser.add_argument("-pele_license", default="/home/kqtw353/stay/external_software/PELErev12279",
                    help=help_descriptions.pele_license_desc)
parser.add_argument("-every", "-fix_every_x_atoms", default=1, type=int, help=help_descriptions.every_desc)
parser.add_argument("-constraint", "-constraint_strength", default=0.2, help=help_descriptions.constraint_desc)
parser.add_argument("-atoms2conStraint", default=[" CA "], nargs='+',
                    help=help_descriptions.atoms2constraint_desc)
parser.add_argument("-mutations_program_path", default="/home/kqtw353/stay/work/mutations_program/mutations_program.py",
                    help=help_descriptions.mutations_program_path_desc)
parser.add_argument("-obc_param_generator", default="/home/kqtw353/stay/work/OBCparamsgen/solventOBCParamsGenerator.py",
                    help=help_descriptions.obc_param_generator_desc)
# parser.add_argument("-sub_template", default="./submit_template.sh")
args = parser.parse_args()

# The program will always generate a log file.
logging.basicConfig(filename=args.log_file, format="%(message)s", level=logging.INFO, filemode="w")
logging.info("{} : Program starting".format(datetime.datetime.now().strftime("%Y-%m-%d %H:%M")))

# The first step to do is to check if the arguments are in the right format:
# the input files and the receptor should be either in .pdb or .mae formats,
# to check for this a pattern will be used.

# These are the commands that will be executed during the program, they change depending
# on where the program is being executed AZ or BSC
# This line is mandatory only for AZ, as the import
# The first thing is to load the schrodinger module
module("load", "schrodinger/2016.01")
# Then we load the commands from the constant values depending on where we are.
# Commands AZ
schrodinger_mae2pdb_convert_command = "pdbconvert -imae {} -opdb {}"
schrodinger_pdb2mae_convert_command = "pdbconvert  -ipdb {} -omae {}"
ploprottemp = "{}/utilities/python {}".format(args.schrodinger_path, args.plop_path)
ploprottemp_command = ploprottemp + " {} -mae_charges=no -mtor=5 -g=30 -clean=yes"
mutations_program_command = "python " + args.mutations_program_path + \
                            " -ipdb {} -make_unique Z -gaps_ter "
# Commands BSC
# schrodinger_converter = "{}/utilities/pdbconvert ".format(args.schrodinger_path)
# schrodinger_mae2pdb_convert_command = schrodinger_converter + " -imae {} -opdb {}"
# schrodinger_pdb2mae_convert_command = schrodinger_converter + " -ipdb {} -omae {}"
# ploprottemp = "{}/utilities/python {}".format(args.schrodinger_path, args.plop_path)
# ploprottemp_command = ploprottemp + "{} -mae_charges=no -mtor=5 -g=30 -clean=yes"
# mutations_program_command = "python " + args.mutations_program_path + \
#                             " -ipdb {} -make_unique Z -gaps_ter "

obc_param_generator = "python {}".format(args.obc_param_generator)
obc_param_command = obc_param_generator + " {}"

command_fist_execution = {"ploprottemp": True, 'mae2pdb_convert': True, 'pdb2mae_convert': True,
                          'mutations_program': True, 'obc_param_gen': True}

# Set up a counter for non-critical errors and warnings to do a simple summary in the log file.
errors_counter = 0
warnings_counter = 0

# check if the path from the option subfolder_path, ends in the system separator otherwise it adds it,
# by default the program creates the subfolders in the directory where the program is executed.
if args.subfolders_path[-1] != os.sep:
    subfolders_path = args.subfolders_path + os.sep
else:
    subfolders_path = args.subfolders_path
if not os.path.isdir(args.subfolders_path):
    if args.not_interactive:
        logging.critical("ERROR: The path to create the subfolders doesn't exist, it should be created previously "
                         "by the user. The program will be terminated.")
        logging.shutdown()
        sys.exit("In the not interactive mode the user should have created previously the general folder where the new"
                 "folders should be created.\nTerminating the program")
    else:
        print "The path to create the subfolders doesn't exist"
        answer = raw_input("Do you want to create the folder {}? Y/n\n".format(args.subfolders_path))
        if search("n.*", answer, IGNORECASE):
            answer = raw_input("Do you want to create and use another path? y/[N]?\n")
            if search("n", answer, IGNORECASE) or answer == "":
                logging.critical("ERROR: The path to create the subfolders doesn't exist\n"
                                 "The user has chosen to terminate the program")
                sys.exit("The program will be terminated.")
            else:
                new_subfolders_path = raw_input("Please introduce the path where the folders should be generated:\n")
                print "Creating the folder {}".format(new_subfolders_path)
                os.mkdir(new_subfolders_path)
                current_directory = os.getcwd()
                args.subfolders_path = current_directory + new_subfolders_path
                logging.info("The folder {} has been created and the new folders will be generated in it.")
        elif search("y.*", answer, IGNORECASE) or answer == "":
            os.mkdir(args.subfolders_path)
            print "Creating the folder {}".format(args.subfolders_path)
            logging.info("The folder {} has been created and the new folders will be generated in it.")

# check the format of the receptor file if it exists, if it isn't valid the program is terminated.
if args.receptor:
    format_ok = findall(accepted_formats, args.receptor)
    if not format_ok or len(format_ok) > 1:
        logging.critical("ERROR: The format of the receptor file isn't valid.\n\Terminating the program.")
        sys.exit("ERROR: The format of the receptor file isn't valid.\n\Terminating the program.")
    else:
        logging.info("The receptor file specified is: {}\n".format(args.receptor))
        receptor_format = format_ok[0]
    form_complexes = True
    logging.info("INFO: The input files will be treated as single ligands and the receptor "
                 "file will be used to form all the complexes\n")
    is_mae_file = search("(.*)\.mae", args.receptor)
    if is_mae_file:
        print "The receptor file will be converted to .pdb format using schrodinger's converter."
        logging.info("The receptor file will be converted to .pdb format using schrodinger's converter."
                     " This new file will be used as the receptor.")
        receptor_pdb = is_mae_file.group(1) + ".pdb"
        command2call = schrodinger_mae2pdb_convert_command.format(args.receptor, receptor_pdb)
        try:
            check_call(command2call.split())
        except CalledProcessError as error_message:
            print "The pdbconverter of maestro failed to when being execute. The program will be terminated."
            logging.critical("ERROR: The pdbconverter from schrodinger couldn't be executed.")
            logging.info("The error is in the command ' {} '".format(command2call))
            logging.shutdown()
            sys.exit("Program terminated due to the error:\n{}".format(error_message))
        args.receptor = receptor_pdb
else:
    form_complexes = False

# check if the input files are in the right format, if any of them isn't it will be skipped
input_files = []
number_of_skipped_files = 0
heading = "The following files don't have the right extension (the program will skip them):"
for filename in args.input_files:
    format_ok = findall(accepted_formats, filename)
    if not format_ok or len(format_ok) > 1:
        if number_of_skipped_files == 0:
            number_of_skipped_files += 1
            line = heading + " {}. {}".format(number_of_skipped_files, filename)
        else:
            line = " {}. {}".format(number_of_skipped_files, filename)
        logging.info(line)
    else:
        input_files.append(filename)
if input_files:
    if number_of_skipped_files == 0:
        logging.info("All the input files have the right format.")
    logging.info("The input files are {}".format("\n".join([filename for filename in input_files])))
else:
    logging.critical("\nERROR: None of the files specified in the input has the right format."
                     "\nTerminating the program.")
    logging.info("The input files are {}".format("\n".join([filename for filename in input_files])))
    logging.shutdown()
    sys.exit("ERROR: No valid input file.\nTerminating the program.")

# Check the template to look for the parameters to generate.
if search("none", args.conf_template, IGNORECASE) is None:
    with open(args.conf_template, 'r') as template_file:
        logging.info(" - Creating the Templates.")
        template_text = "".join(template_file.readlines())
        keywords_in_the_template = set(pattern.group(1) for pattern in finditer("\$\{*(\w*_*w*)\}?", template_text))
        solvent_type = search(r'"solventType" : "(.*)",', template_text).group(1)
    if solvent_type is None:
        logging.critical("ERROR: The template doesn't specify the solvent type PELE won't work.")
        logging.info("Terminating the program")
        logging.shutdown()
        sys.exit("Terminating the program.\nThe configuration file doesn't specify the solvent type.")
    else:
        solvent_type = solvent_type.lower()
    generate_template = True
else:
    logging.info("The program won't generate any configuration file.")
    print "No configuration file will be generated."
    solvent_type = ""
    generate_template = False
    keywords_in_the_template = {}
    template_text = ""

configuration_files_names = []

# This huge for loop takes care of all the preparation for each system. From creating the folders
# to generate the configuration file needed for PELE, it also
for filename in input_files:
    logging.info("Working with file: {}".format(filename))
    minimum_filename = filename.split(os.sep)[-1]
    new_folder_name = ".".join(minimum_filename.split(".")[:-1])
    new_general_subfolder = subfolders_path + new_folder_name + os.sep
    exists_already = False
    # The next step is to create a folder for each file, these subfolders will be generated in the
    # directory specified by the option subfolder_path and copy the file.
    logging.info(" - Creating the folder {}".format(new_general_subfolder))
    # These long try: error blocks are to enable the program to finish if the folders already exist. In which
    # case new ones won't be generated.
    try:
        os.mkdir(new_general_subfolder)
    except OSError:
        logging.info(
            "   -WARNING: The folder {} already exists. So it won't be created again.".format(new_general_subfolder))
        exists_already = True
    else:
        logging.info("   - Folder created correctly")

    # This block also generates all the folders and links needed to launch a PELE simulations
    # in the new folders. If the folders exist from previous runs they'll be kept
    logging.info(" - Creating the subfolder DataLocal and all its subfolders.")

    datalocal_folder = new_general_subfolder + "DataLocal" + os.sep
    try:
        os.mkdir(datalocal_folder)
    except OSError:
        if not exists_already:
            logging.info(
                "The folder {} already exists. But the folder {} is being created now.".format(new_general_subfolder,
                                                                                               datalocal_folder))
    rotamerlibs_folder = datalocal_folder + "LigandRotamerLibs" + os.sep
    try:
        os.mkdir(rotamerlibs_folder)
    except OSError:
        if not exists_already:
            logging.info("The folder {} already exists. So it won't be created again.".format(rotamerlibs_folder))
    templates_folder = datalocal_folder + "Templates" + os.sep
    try:
        os.mkdir(templates_folder)
    except OSError:
        logging.info("The folder {} already exists. So it won't be created again.".format(templates_folder))
    opls_folder = templates_folder + "OPLS2005" + os.sep
    try:
        os.mkdir(opls_folder)
    except OSError:
        logging.info("The folder {} already exists. So it won't be created again.".format(opls_folder))
    hetero_folder = opls_folder + "HeteroAtoms" + os.sep
    try:
        os.mkdir(hetero_folder)
    except OSError:
        logging.info("The folder {} already exists. So it won't be created again.".format(hetero_folder))
    output_folder = new_general_subfolder + "output"
    try:
        os.mkdir(output_folder)
    except OSError:
        logging.info("The folder {} already exists. So it won't be created again.".format(output_folder))
    pele_data = args.pele_folders + os.sep + "Data"
    link2data = new_general_subfolder + "Data"
    try:
        os.symlink(pele_data, link2data)
    except OSError:
        logging.info("The link {} already exists. So it won't be created again.".format(link2data))
    pele_documents = args.pele_folders + os.sep + "Documents"
    link2documents = new_general_subfolder + "Documents"
    try:
        os.symlink(pele_documents, link2documents)
    except OSError:
        logging.info("The link {} already exists. So it won't be created again.".format(link2documents))
    # Links and subfolders created.

    # Now the program copies the input file into the newly created folder.
    file_copy = new_general_subfolder + minimum_filename
    if args.debug:
        print filename
        print file_copy
    copyfile(filename, file_copy)
    # If the file is in .mae format it'll be converted to .pdb format to be able to do the checks
    # and modifications needed in a simpler way.
    is_mae_file = search("(.*)\.mae", file_copy)
    if is_mae_file:
        #  The input file has .mae format so it should be transformed to .pdb format
        file_in_pdb_format = is_mae_file.group(1) + ".pdb"
        command2call = schrodinger_mae2pdb_convert_command.format(file_copy, file_in_pdb_format)
        file_copy = file_in_pdb_format
        try:
            check_call(command2call.split())
        except CalledProcessError as error_message:
            print "The pdbconverter of maestro failed to when being execute. The program will be terminated."
            logging.critical("ERROR: The pdbconverter from schrodinger couldn't be executed.")
            logging.info("The error is in the command ' {} '".format(command2call))
            logging.shutdown()
            sys.exit("Program terminated due to the error:\n{}".format(error_message))
    # If no receptor is specified the program assumes the original file is a complex and will try to generate
    # a _receptor.pdb file and a _ligand.pdb file extracting the chain Z from the original file.
    if form_complexes:
        # This option should be chosen only if the user has specified a receptor file.
        # If a receptor is given copy it to the new folder.
        if args.receptor == filename:
            logging.info(" - INFO: The receptor file and this ligand share the same name,"
                         " the receptor will be renamed")
            pattern4new_receptor = search("(.*)(\.mae|\.pdb)", args.receptor)
            if pattern4new_receptor is None:
                # This shouldn't happen ever since a similar pattern has been checked previously...
                logging.critical("There's a problem in the code, tell the developer code L281")
                logging.shutdown()
                sys.exit("You got somewhere where it should be impossible to get. Code Line 116")
            else:
                new_receptor_name = "{0}_1{1}".format(pattern4new_receptor.group(1), pattern4new_receptor.group(2))
                receptor_copy = new_general_subfolder + new_receptor_name
                logging.info("INFO: The receptor file in the folder {} is named {}".format(new_general_subfolder,
                                                                                           new_receptor_name))
        else:
            if os.sep in args.receptor:
                receptor_copy = new_general_subfolder + args.receptor.split(os.sep)[-1]
            else:
                receptor_copy = new_general_subfolder + args.receptor
        if args.debug:
            print receptor_copy
        copyfile(args.receptor, receptor_copy)
        receptor_filename = receptor_copy
        ligand_filename = file_copy
        no_need4template = check_ligand(ligand_filename)
        logging.info(" - Generating the complex file.")
        with open(receptor_filename, 'r') as receptor_file:
            complex_text = ""
            for line in receptor_file:
                if line.startswith("ATOM") or line.startswith("HETATM") or line.startswith("TER"):
                    complex_text += line
        with open(ligand_filename, 'r') as ligand_file:
            for line in ligand_file:
                if line.startswith("ATOM") or line.startswith("HETATM") or line.startswith("TER"):
                    complex_text += line
        if complex_text:
            complex_filename = new_general_subfolder + new_folder_name + "_complex.pdb"
            with open(complex_filename, 'w') as complex_file:
                complex_file.write(complex_text)
        else:
            # If the code gets here is due to the fact that the receptor and the ligand files are empty so
            # it shouldn't continue.
            logging.critical("There's a problem in the code, tell the developer code L446")
            logging.shutdown()
            print "BU!! NOT WORKING!"  # TODO:Change this message to something more serious
            sys.exit("See what's happening..LINE 277 ")
    else:
        # The program assumes that if the initial structure is a complex it will have only on copy of the ligand
        # in chain Z.
        with open(file_copy, 'r') as complex_file:
            ligand = ""
            receptor = ""
            for line in complex_file:
                if args.debug:
                    print file_copy
                if "ATOM" in line or "HETATM" in line:
                    if line[21] in ["Z", "z"]:
                        ligand += line
                elif line == "TER\n" and ligand:
                    ligand += line
                else:
                    receptor += line
        if ligand:
            logging.info(" - Extracting the ligand from the complex.")
            ligand_filename = new_general_subfolder + new_folder_name + "_ligand.pdb"
            complex_filename = file_copy
            with open(ligand_filename, 'w') as ligand_file:
                ligand_file.write(ligand)
                # In this case we don't really the receptor in a separated file since we already have the complex.
                # receptor_filename = new_general_subfolder + new_folder_name + "_receptor.pdb"
                # with open(receptor_filename, 'w') as receptor_file:
                #     receptor_file.write(receptor)
        else:
            # If the program hasn't found a chain Z it won't generate the files
            logging.info(" - There's nothing in chain Z for the file {}.".format(file_copy))
            logging.warning(" -WARNING: The procedure for the folder {} will be interrupted from now on.".format(
                new_general_subfolder))
            warnings_counter += 1
            continue
        no_need4template = check_ligand(ligand_filename)

    # block calling the mutations program to generate the preprocessed
    # .pdb file
    logging.info(" - Calling the 'mutations_program.py' to format the complex file.")
    command2call = mutations_program_command.format(complex_filename)
    file_preparation_output = check_output(command2call.split(), stderr=STDOUT)
    # We want to use the file generated by the mutations program since it will have the correct format for PELE.
    if "Writing the structure to" not in file_preparation_output:
        error_filename = new_general_subfolder + new_folder_name + "_preparation_error_log.txt"
        logging.error(
            " - ERROR: The mutations program hasn't been able to prepare the complex file for the file.\n"
            "   More information about this error in the file {}".format(error_filename))
        errors_counter += 1
        with open(error_filename, 'w') as error_file:
            error_file.write(file_preparation_output)
        complex_filename = complex_filename.split('/')[-1]
        logging.info(" - The original complex will be used: {}".format(complex_filename))
    else:
        file4pele = complex_filename.split('.pdb')[0] + "_processed.pdb"
        logging.info(" - The file ready for pele it's called: {}".format(file4pele))
        # The configuration file and this file will be in the same folder thus we just need the name of
        # the complex and not the whole path.
        complex_filename = file4pele.split('/')[-1]
    if ".pdb" not in ligand_filename:
        print "ligand_filename:", ligand_filename
        logging.critical("There's a problem in the code, tell the developer code L354")
        logging.shutdown()
        sys.exit("Programming error in here! The ligand isn't in .pdb format")
    # Now that we've made sure the ligand is in chain Z and it has a normal name or LIG as the residue name
    # we convert it to .mae format, so we can create the template. Unless the ligand it's a peptide in
    # which case we don't need to generate a template.
    if not no_need4template:
        ligand_template_filename = create_template_and_rotamerlib(ligand_filename, hetero_folder, rotamerlibs_folder,
                                                                  command_fist_execution['ploprottemp'])
        if ligand_template_filename:
            command_fist_execution['ploprottemp'] = False
        else:
            logging.info(" - The template hasn't been generated for this system. It'll be discotinued")
            errors_counter += 1
            continue
        if not ligand_template_filename:
            errors_counter += 1
            continue
        # generating the solvent parameter for the ligand if the desired solvent is OBC.
        if solvent_type == "obc":
            logging.info("Generating the solvent parameters.")
            original_obc_param = args.pele_folders + os.sep + "Data/OBC/solventParamsHCTOBC.txt"
            copy_obc_folder = datalocal_folder + "OBC" + os.sep
            try:
                os.mkdir(copy_obc_folder)
            except OSError as e:
                if search(r"exists", e[1]):
                    pass
                else:
                    print "SHIT.", e
            copy_obc_param = copy_obc_folder + "solventParamsHCTOBC.txt"
            copyfile(original_obc_param, copy_obc_param)
            command2call = obc_param_command.format(ligand_template_filename)
            # print command2call
            try:
                cmd_output = check_output(command2call.split(), stderr=STDOUT)
            except CalledProcessError as error_message:
                print "The program failed to execute the OBC script. The program will be terminated."
                logging.critical("ERROR: The script to generate the OBC parameters couldn't be executed.")
                logging.info("The error is in the command ' {} '".format(command2call))
                logging.shutdown()
                sys.exit("Program terminated due to the error:\n{}".format(error_message))
            obc_command_output_file = ligand_template_filename + "_OBCParams.txt"
            if os.path.isfile(obc_command_output_file):
                with open(obc_command_output_file, 'r') as obc_template_file:
                    obc_text = "".join(obc_template_file.readlines()) + "\n"
                with open(copy_obc_param, 'a') as obc_param_file:
                    obc_param_file.write(obc_text)
                os.remove(obc_command_output_file)
            else:
                logging.error(" - ERROR: The OBC parameters required couldn't be generated.")
                errors_counter += 1
                logging.info(" INFO: This system will be discontinued.")
                continue
    # This block creates the configuration file into the folder.
    if generate_template:
        keywords_values = {}
        for keyword in keywords_in_the_template:
            if search(".*constraints", keyword, IGNORECASE):
                if args.debug:
                    print "file4pele: ", file4pele
                constraints = obtain_constraints_from_pdb(file4pele, args.every, args.constraint,
                                                          args.atoms2conStraint)
                if not constraints:
                    print "Couldn't generate the constraints for file {}".format(complex_filename)
                    logging.error("  ERROR: Couldn't generate the constraints for file {}".format(complex_filename))
                    logging.info(" This system will be discontinued since constraints couldn't be generated.")
                    errors_counter += 1
                    continue
                # obtain constraints from a pdb file
                keywords_values[keyword] = constraints
            elif search("center_*of_*mass", keyword, IGNORECASE):
                mass_center = compute_center_of_mass(ligand_filename)
                if not mass_center:
                    logging.warning("  WARNING: This system will be discontinued. Couldn't compute the center of mass.")
                    logging.info("INFO: to solve this problem talk with he developer and provide the ligand file.")
                    warnings_counter += 1
                    continue
                keywords_values[keyword] = mass_center
            elif search("input.*", keyword, IGNORECASE):
                keywords_values[keyword] = complex_filename
            elif search("license.*", keyword, IGNORECASE):
                keywords_values[keyword] = args.pele_license
            elif search("system.*", keyword, IGNORECASE):
                keywords_values[keyword] = new_folder_name
            else:
                print "The keyword '{}' isn't a valid one".format(keyword)
                logging.warning("  WARNING: This system will be discontinued. The keyword {} isn't a valid one".format(
                    keyword))
                logging.info("INFO: Check your keyword if it should be valid talk with he developer and provide "
                             "the template file.")
                warnings_counter += 1
                continue
                # Every time a new keyword appears a new search should be added.
        template = Template(template_text)
        try:
            new_conf_file_text = template.substitute(keywords_values)
        except ValueError as e:
            logging.critical("ERROR: the configuration file template isn't able to obtain all the needed values.")
            logging.critical("The program has been terminated.")
            logging.shutdown()
            print "Programing error. Talk with the developer. Code L549"
            if args.debug:
                print keywords_in_the_template
                print keywords_values.keys()
            print e
            sys.exit("Error when creating the configuration file, missing keywords.")
        else:
            new_conf_file_filename = new_general_subfolder + new_folder_name + ".conf"
            with open(new_conf_file_filename, 'w') as new_conf_file:
                new_conf_file.write(new_conf_file_text)
        configuration_files_names.append(new_conf_file_filename)

# Now we have to create a file to submit the jobs. The file will depend on where they want to be run, so
# we should use a template, also there are some requirements that change depending on BSC/AZ
# In AZ the nodes have 12 physical cores so all the jobs should be  multiple of 24 or 12
# with open(args.sub_template, 'r') as sub_template_file:
#     sub_template_text = "".join(sub_template_file.readlines())

logging.info("{} : Program finished normally with {} warnings and {} non-critical errors.".format(
    datetime.datetime.now().strftime("%Y-%m-%d %H:%M"), warnings_counter, errors_counter))
logging.shutdown()
